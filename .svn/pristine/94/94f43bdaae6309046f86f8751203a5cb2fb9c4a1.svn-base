using Microsoft.Win32;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Data;
using System.Windows.Documents;
using System.Windows.Forms;
using System.Windows.Input;
using System.Windows.Media;
using System.Windows.Media.Imaging;
using System.Windows.Navigation;
using System.Windows.Shapes;
using System.IO.Compression;
using System.Drawing;



namespace bien4read
{
    /// <summary>
    /// MainWindow.xaml에 대한 상호 작용 논리
    /// </summary>
    public partial class MainWindow : Window
    {
        List<FileInfo> m_pathList = new List<FileInfo>();
        String MY_FOLDER = "b4r";
        String REG_KEY = "b4r";
        String REG_KEY_PATH = "path";
        String PATH_DEFAULT = @"D:\test";
        RegistryKey m_reg;

        public MainWindow()
        {
            InitializeComponent();

            string regPath = readRegPath();
            tbPath.Text = regPath;

            addMsg("### 프로그램이 시작되었습니다. ###");
        }

        private string readRegPath()
        {
            m_reg = Registry.LocalMachine.CreateSubKey("Software").CreateSubKey(REG_KEY);

            String path = Convert.ToString(m_reg.GetValue(REG_KEY_PATH, PATH_DEFAULT));
            return path;
        }

       

        private void addMsg(string v)
        {
          
            // 현재시각 구하기
            String t = System.DateTime.Now.ToString("[hh:mm:ss]:");
            string newMsg = t + v + "\n";
            tbMsg.Text = tbMsg.Text.Insert(0, newMsg);
            //tbMsg.SelectedText = newMsg;
            //tbMsg.Text = t + v + "\n" + tbMsg.Text;

            int lineIndex = tbMsg.GetLineIndexFromCharacterIndex(tbMsg.CaretIndex);
            tbMsg.ScrollToLine(lineIndex);

            this.Dispatcher.Invoke((ThreadStart)(() => { }), System.Windows.Threading.DispatcherPriority.ApplicationIdle);
        }

        private void btnPath_Click(object sender, RoutedEventArgs e)
        {
            //경로를 선택할 수 있는 창을 보여준다.
            FolderBrowserDialog d = new FolderBrowserDialog();
            d.SelectedPath = tbPath.Text;
            if (d.ShowDialog() != System.Windows.Forms.DialogResult.OK) {
                return;
            }

            String selPath = d.SelectedPath;
            changePath(selPath);
            //tbPath.Text = selPath;
        }

        private void changePath(string selPath)
        {
            m_reg.SetValue(REG_KEY_PATH, selPath);
            tbPath.Text = selPath;
        }

        private void btnChange_Click(object sender, RoutedEventArgs e)
        {
            // 해당 경로가 유효한지 확인
            String selPath = tbPath.Text;

            // 선택한 경로 이하의 모든 폴더 및 파일을 읽는다.
            System.IO.DirectoryInfo di = new System.IO.DirectoryInfo(selPath);
            if (di.Exists == false) {
                System.Windows.MessageBox.Show("유효한경로를 선택하세요");
                return;
            }

            // 기존 정보 모두 삭제
            m_pathList.Clear();

            addFilesToList(di);

            
            // 리스트에 있는 것들을 하나씩 꺼내서, 처리
            foreach (FileInfo f in m_pathList) {
                // 변환 폴더 생성
                String savePath = f.DirectoryName + "\\" + MY_FOLDER + "\\";
                createDirectory(savePath);

                // txt 파일 처리
                if (f.Extension.Equals(".txt")){
                    //addMsg(f.Name + " is txt file");

                    String utf8Text = readFileAsUtf8(f.FullName);
                    utf8Text = removeNewLine(utf8Text);

                    //Console.WriteLine("===============rst==============");
                    //Console.WriteLine(utf8Text);
                    //string name = System.IO.Path.GetFileNameWithoutExtension(f.Name);
                    
                    System.IO.File.WriteAllText(savePath + f.Name, utf8Text, Encoding.UTF8);

                    addMsg(f.Name + " 파일 변환");
                }
                // zip 파일 처리
                else if (f.Extension.Equals(".zip")){
                    using (ZipArchive archive = ZipFile.OpenRead(f.FullName)) {
                        foreach (ZipArchiveEntry entry in archive.Entries) {
                            // txt 파일이면,
                            if (isExtFile(entry.FullName, "txt")) {
                                String utf8Text = readEntryAsUtf8(entry.Open());
                                utf8Text = removeNewLine(utf8Text);
                                System.IO.File.WriteAllText(savePath + f.Name + "_" + entry.Name, utf8Text, Encoding.UTF8);
                                addMsg(f.Name + " 파일 변환");
                            }
                            // 이미지 파일이면,
                            // 참고: http://stackoverflow.com/questions/734930/how-to-crop-an-image-using-c
                            if (isImageFile(entry)) {
                                string ext = System.IO.Path.GetExtension(entry.FullName);
                                Stream s = entry.Open();
                                Bitmap bm = new Bitmap(s);
                                //bm.Save(savePath + f.Name + "_" + entry.Name, System.Drawing.Imaging.ImageFormat.Gif);

                                // 가로가 더 긴 경우에는 이미지를 분할하여 저장한다. 
                                // 필요없는 부분은 CROP 하여 저장한다.
                                // 임시폴더에 저장하고, 
                                // 이하 부분은 foreach가 끝나고 나서 처리해야 함.
                                // ==> 압축하여, 저장한다.
                                // ==> 그리고 임시폴더 삭제
                            }
                        }
                    }            
                }
            }

            addMsg("### 변환 완료 ###");
        }

        private bool isImageFile(ZipArchiveEntry entry)
        {
            string[] exts = { "jpg", "jpeg", "bmp", "gif" };

            foreach (string ext in exts) {
                if (isExtFile(entry.FullName, ext))
                    return true;
            }

            return false;
        }

        private bool isExtFile(string name, string ext)
        {
            if (name.EndsWith("." + ext, StringComparison.OrdinalIgnoreCase)) {
                return true;
            }

            return false;
        }



        private void createDirectory(string savePath)
        {
            DirectoryInfo di = new DirectoryInfo(savePath);
            if (di.Exists == false)
                di.Create();
        }

        private string removeNewLine(string utf8Text)
        {
            string rst = string.Empty;
            string[] stringSeperators = new string[] { "\r\n" };
            string[] lines = utf8Text.Split(stringSeperators, StringSplitOptions.None);

            int addedLine = 0;

            for (int i = 0; i < lines.Length - 1; i++) {
                string sCur = lines[i];
                string sNext = lines[i + 1];

                string spacePattern = @"(?<=\w)\s+";
                Regex reg = new Regex(spacePattern);
                sCur = reg.Replace(sCur, " ");
                
                bool bAddNewLine = false;

                string pat = @"^\w";
                Regex r = new Regex(pat, RegexOptions.IgnoreCase);
                Match m = r.Match(sNext);

                if (m.Success == false || sCur.Length < 30)
                {
                    bAddNewLine = true;
                }
                else {
                    addedLine++;
                }
                
                if (bAddNewLine)
                {
                    sCur += "\r\n";

                    if (addedLine > 10)
                    {
                        sCur += "\r\n";
                    }
                    addedLine = 0;
                }

                


                rst += sCur;
            }

            rst += lines[lines.Length - 1];

            return rst;
        }

        private string readEntryAsUtf8(Stream s)
        {
            Encoding encoding = Encoding.Default;
            String original = String.Empty;

            using (StreamReader sr = new StreamReader(s, Encoding.Default))
            {
                original = sr.ReadToEnd();
                encoding = sr.CurrentEncoding;
                sr.Close();
            }

            if (encoding == Encoding.UTF8)
                return original;

            byte[] encBytes = encoding.GetBytes(original);
            byte[] utf8Bytes = Encoding.Convert(encoding, Encoding.UTF8, encBytes);
            return Encoding.UTF8.GetString(utf8Bytes);
        }


        private String readFileAsUtf8(string filename)
        {
            Encoding encoding = Encoding.Default;
            String original = String.Empty;

            using (StreamReader sr = new StreamReader(filename, Encoding.Default)) {
                original = sr.ReadToEnd();
                encoding = sr.CurrentEncoding;
                sr.Close();                    
            }

            if (encoding == Encoding.UTF8)
                return original;

            byte[] encBytes = encoding.GetBytes(original);
            byte[] utf8Bytes = Encoding.Convert(encoding, Encoding.UTF8, encBytes);
            return Encoding.UTF8.GetString(utf8Bytes);
        }

        private Encoding findFileEncoding(FileInfo f)
        {
            FileStream fs = null;
            int bomByteLen = 4;

            try
            {
                fs = File.OpenRead(f.FullName);
                byte[] BOMBytes = new byte[bomByteLen];
                fs.Read(BOMBytes, 0, bomByteLen);

                if (BOMBytes == null)
                    throw new ArgumentNullException("Must provide a valid BOM byte array!", "BOMBytes");

                if (BOMBytes.Length < 2)
                    return null;

                if (BOMBytes[0] == 0xff
                    && BOMBytes[1] == 0xfe
                    && (BOMBytes.Length < 4
                        || BOMBytes[2] != 0
                        || BOMBytes[3] != 0
                        )
                    )
                    return Encoding.Unicode;

                if (BOMBytes[0] == 0xfe
                    && BOMBytes[1] == 0xff
                    )
                    return Encoding.BigEndianUnicode;

                if (BOMBytes.Length < 3)
                    return null;

                if (BOMBytes[0] == 0xef && BOMBytes[1] == 0xbb && BOMBytes[2] == 0xbf)
                    return Encoding.UTF8;

                if (BOMBytes[0] == 0x2b && BOMBytes[1] == 0x2f && BOMBytes[2] == 0x76)
                    return Encoding.UTF7;

                if (BOMBytes.Length < 4)
                    return null;

                if (BOMBytes[0] == 0xff && BOMBytes[1] == 0xfe && BOMBytes[2] == 0 && BOMBytes[3] == 0)
                    return Encoding.UTF32;

                if (BOMBytes[0] == 0 && BOMBytes[1] == 0 && BOMBytes[2] == 0xfe && BOMBytes[3] == 0xff)
                    return Encoding.GetEncoding(12001);

                return null;

            }
            finally {
                if (fs != null) {
                    fs.Close();
                    fs.Dispose();
                }
            }
        }

        private void addFilesToList(DirectoryInfo di)
        {
            // 마지막 경로가 이 프로그램을 통해서 만든 경로라면 처리하지 않는다.
            int totalLen = di.FullName.Length;
            int myLen = MY_FOLDER.Length;

            if (totalLen > myLen)
            {
                String lastDirectory = di.FullName.Substring(totalLen - myLen, myLen);
                if (lastDirectory == MY_FOLDER)
                    return;
            }

            // 처리 대상 확장자
            string[] exts = { "txt", "zip" };

            // 파일 정보 가져오기
            foreach (System.IO.FileInfo f in di.GetFiles())
            {
                foreach (string ext in exts) {
                    m_pathList.Add(f);
                    addMsg(f.FullName + " 파일 추가");
                }
            }

            // 폴더 정보 가져오기
            foreach (System.IO.DirectoryInfo d in di.GetDirectories()) {
                addFilesToList(d);
            }
        }

        private void tbPath_Drop(object sender, System.Windows.DragEventArgs e)
        {
            if (e.Data.GetDataPresent(System.Windows.DataFormats.FileDrop, true))
            {
                string[] droppedPaths = e.Data.GetData(System.Windows.DataFormats.FileDrop, true) as string[];
                string path = droppedPaths[0];

                DirectoryInfo di = new DirectoryInfo(path);
                string rstPath = string.Empty;

                if (di.Exists)
                {                    
                    rstPath = path;
                }
                else {
                    FileInfo fi = new FileInfo(path);
                    rstPath = fi.DirectoryName;
                }

                changePath(rstPath);
            }
        }

        private void tbPath_PreviewDragEnter(object sender, System.Windows.DragEventArgs e)
        {
            if (e.Data.GetDataPresent(System.Windows.DataFormats.FileDrop))
            {
                e.Effects = System.Windows.DragDropEffects.Copy;
            }
            else
            {
                e.Effects = System.Windows.DragDropEffects.None;
            }
        }

        private void tbPath_PreviewDragOver(object sender, System.Windows.DragEventArgs e)
        {
            e.Handled = true;
        }

        private void tbAddEmptyLine_KeyPress(object sender, KeyPressEventArgs e)
        {
            //숫자,백스페이스,마이너스,소숫점 만 입력받는다.
            if (!(Char.IsDigit(e.KeyChar)) && e.KeyChar != 8) //8:백스페이스,45:마이너스,46:소수점
            {
                e.Handled = true;
            }
            else {
                e.Handled = false;
            }
        }

    }
}
