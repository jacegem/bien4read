using Microsoft.Win32;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Data;
using System.Windows.Documents;
using System.Windows.Forms;
using System.Windows.Input;
using System.Windows.Navigation;
using System.IO.Compression;
using System.Runtime.InteropServices;
using System.Drawing;
using System.Drawing.Imaging;



namespace bien4read
{
    /// <summary>
    /// MainWindow.xaml에 대한 상호 작용 논리
    /// </summary>
    public partial class MainWindow : Window
    {
        List<FileInfo> m_pathList = new List<FileInfo>();
        String MY_FOLDER = "b4r";
        String REG_KEY = "b4r";
        String REG_KEY_PATH = "path";
        String PATH_DEFAULT = @"D:\test";
        RegistryKey m_reg;
        Bitmap m_bm;
        BitmapData m_bitmapData;
        Stream m_stream;
        CropPoint m_cpLeft;
        CropPoint m_cpRight;
        byte[] m_pixels;

        public MainWindow()
        {
            InitializeComponent();

            Dictionary<int, string> dicSplit = new Dictionary<int, string> { { 1, "1→2" }, { 2, "2←1" } };
            cbSplit.ItemsSource = dicSplit;
            cbSplit.DisplayMemberPath = "Value";
            cbSplit.SelectedValuePath = "Key";
            cbSplit.SelectedValue = 2;

            string regPath = readRegPath();
            tbPath.Text = regPath;

            addMsg("### 프로그램이 시작되었습니다. ###");
        }

        private string readRegPath()
        {
            m_reg = Registry.LocalMachine.CreateSubKey("Software").CreateSubKey(REG_KEY);

            String path = Convert.ToString(m_reg.GetValue(REG_KEY_PATH, PATH_DEFAULT));
            return path;
        }

       

        private void addMsg(string v)
        {
          
            // 현재시각 구하기
            String t = System.DateTime.Now.ToString("[hh:mm:ss]:");
            string newMsg = t + v + "\n";
            tbMsg.Text = tbMsg.Text.Insert(0, newMsg);
            //tbMsg.SelectedText = newMsg;
            //tbMsg.Text = t + v + "\n" + tbMsg.Text;

            int lineIndex = tbMsg.GetLineIndexFromCharacterIndex(tbMsg.CaretIndex);
            tbMsg.ScrollToLine(lineIndex);

            this.Dispatcher.Invoke((ThreadStart)(() => { }), System.Windows.Threading.DispatcherPriority.ApplicationIdle);
        }

        private void btnPath_Click(object sender, RoutedEventArgs e)
        {
            //경로를 선택할 수 있는 창을 보여준다.
            FolderBrowserDialog d = new FolderBrowserDialog();
            d.SelectedPath = tbPath.Text;
            if (d.ShowDialog() != System.Windows.Forms.DialogResult.OK) {
                return;
            }

            String selPath = d.SelectedPath;
            changePath(selPath);
            //tbPath.Text = selPath;
        }

        private void changePath(string selPath)
        {
            m_reg.SetValue(REG_KEY_PATH, selPath);
            tbPath.Text = selPath;
        }

        private void btnChange_Click(object sender, RoutedEventArgs e)
        {
            // 해당 경로가 유효한지 확인
            String selPath = tbPath.Text;

            // 선택한 경로 이하의 모든 폴더 및 파일을 읽는다.
            System.IO.DirectoryInfo di = new System.IO.DirectoryInfo(selPath);
            if (di.Exists == false) {
                System.Windows.MessageBox.Show("유효한경로를 선택하세요");
                return;
            }

            // 기존 정보 모두 삭제
            m_pathList.Clear();

            addFilesToList(di);

            
            // 리스트에 있는 것들을 하나씩 꺼내서, 처리
            foreach (FileInfo f in m_pathList) {
                addMsg(f.Name + " 파일 변환");

                // 변환 폴더 생성
                String savePath = getSavePath(f);
                createDirectory(savePath);

                // txt 파일 처리
                if (f.Extension.Equals(".txt")){
                    //addMsg(f.Name + " is txt file");

                    String utf8Text = readFileAsUtf8(f.FullName);
                    utf8Text = removeNewLine(utf8Text);

                    //Console.WriteLine("===============rst==============");
                    //Console.WriteLine(utf8Text);
                    //string name = System.IO.Path.GetFileNameWithoutExtension(f.Name);
                    
                    System.IO.File.WriteAllText(savePath + f.Name, utf8Text, Encoding.UTF8);

                    
                }
                // zip 파일 처리
                else if (f.Extension.Equals(".zip")){
                    string tempDirectory = Path.GetTempPath() + f.Name + "\\";
                    createDirectory(tempDirectory);
                    Boolean bNeddTempProccess = false;

                    using (ZipArchive archive = ZipFile.OpenRead(f.FullName)) {
                        foreach (ZipArchiveEntry entry in archive.Entries) {
                            // txt 파일이면,
                            if (isExtFile(entry.FullName, "txt")) {
                                proccessZipTxt(f, entry);                                
                            }
                            // 이미지 파일이면,
                            // 참고: http://stackoverflow.com/questions/734930/how-to-crop-an-image-using-c
                            if (isImageFile(entry)) {
                                bNeddTempProccess = true;
                                proccessZipImage(f, entry, tempDirectory);                                
                            }
                        }
                    }

                    if (bNeddTempProccess) {
                        deleteFile(getSavePath(f) + f.Name);
                        ZipFile.CreateFromDirectory(tempDirectory, getSavePath(f) + f.Name);
                        // 임시폴더 처리하고 삭제
                        deleteDirectory(tempDirectory);
                    }
                }
            }

            addMsg("### 변환 완료 ###");
        }

        private void deleteFile(string filePath)
        {
            FileInfo f = new FileInfo(filePath);
            if (f.Exists)
                f.Delete();
        }



        
        private void proccessZipImage(FileInfo f, ZipArchiveEntry entry, string tempPath)
        {
            string ext = System.IO.Path.GetExtension(entry.FullName);
            m_stream = entry.Open();
            m_bm = null;
            m_bm = new Bitmap(m_stream);

            m_stream.Close();

            //bm.Save(savePath + f.Name + "_" + entry.Name, System.Drawing.Imaging.ImageFormat.Gif);
            //bmOriginal.Save(getSavePath(f) + f.Name + "_org_" + entry.Name, System.Drawing.Imaging.ImageFormat.Gif);
            //bm.Save(getSavePath(f) + f.Name + "_clone_" + entry.Name, System.Drawing.Imaging.ImageFormat.Gif);

            // Get width and height of bitmap
            int width = m_bm.Width;
            int height = m_bm.Height;

            // get total locked pixels count
            int pixelCount = width * height;

            // get source bitmap pixel format size
            int depth = System.Drawing.Bitmap.GetPixelFormatSize(m_bm.PixelFormat);

            // Create rectangle to lock
            Rectangle rect = new Rectangle(0, 0, width, height);

            // Check if bpp (Bits Per Pixel) is 8, 24, or 32
            if (depth != 8 && depth != 24 && depth != 32)
            {
                throw new ArgumentException("Only 8, 24 and 32 bpp images are supported.");
            }

            // Lock bitmap and return bitmap data
            m_bitmapData = null;
            m_bitmapData = m_bm.LockBits(rect, ImageLockMode.ReadOnly, m_bm.PixelFormat);
        
            // create byte array to copy pixel values
            int step = depth / 8;

            m_pixels = null;
            m_pixels = new byte[pixelCount * step];

            for (int i = 0; i < 2000; i++) {
                m_pixels[i] = 123;
            }



            IntPtr Iptr = m_bitmapData.Scan0;

            // Copy data from pointer to array
            Marshal.Copy(Iptr, m_pixels, 0, m_pixels.Length);

            for (int i = 0; i < pixelCount * step; i++)
            {
                if (m_pixels[i] != 0)
                {
                    //Console.WriteLine("NOT ZERO: {0}", i);
                }
            }

            // unlockbits
            m_bm.UnlockBits(m_bitmapData);

            //Bitmap bm = bmOriginal.Clone(new Rectangle(0, 0, width, height), PixelFormat.Format24bppRgb);
            
            int searchValue = 10;

            int marginUD = Convert.ToInt32(tbMarginUD.Text);
            int marginLR = Convert.ToInt32(tbMarginLR.Text);

            ImageFormat imageFormat = System.Drawing.Imaging.ImageFormat.Bmp;

            if (ext.Equals(".gif", StringComparison.OrdinalIgnoreCase))
                imageFormat = System.Drawing.Imaging.ImageFormat.Gif;
            else if (ext.Equals(".bmp", StringComparison.OrdinalIgnoreCase))
                imageFormat = System.Drawing.Imaging.ImageFormat.Bmp;
            else if (ext.Equals(".jpg", StringComparison.OrdinalIgnoreCase))
                imageFormat = System.Drawing.Imaging.ImageFormat.Jpeg;
            else if (ext.Equals(".jpeg", StringComparison.OrdinalIgnoreCase))
                imageFormat = System.Drawing.Imaging.ImageFormat.Jpeg;
            else if (ext.Equals(".png", StringComparison.OrdinalIgnoreCase))
                imageFormat = System.Drawing.Imaging.ImageFormat.Png;


            string savePath = tempPath;
            //string savePath = getSavePath(f);

            // 반으로 나눠야 하는가?
            if (width > height)
            {
                m_cpLeft = new CropPoint(m_pixels, 0, 0, width / 2, height, depth, searchValue, width, height);
                m_cpRight = new CropPoint(m_pixels, width / 2, 0, width, height, depth, searchValue, width, height);

                m_cpLeft.addMargin(marginUD, marginLR);
                m_cpRight.addMargin(marginUD, marginLR);

                Bitmap bm1, bm2;

                // 순서에 따라 저장
                if (cbSplit.SelectedValue.Equals(1))
                {
                    bm1 = m_bm.Clone(m_cpLeft.getRectangle(), m_bm.PixelFormat);
                    bm2 = m_bm.Clone(m_cpRight.getRectangle(), m_bm.PixelFormat);
                }
                else
                {
                    bm1 = m_bm.Clone(m_cpRight.getRectangle(), m_bm.PixelFormat);
                    bm2 = m_bm.Clone(m_cpLeft.getRectangle(), m_bm.PixelFormat);
                }

                bm1.Save(savePath + f.Name + modifyName(entry.Name, "_c1_"), imageFormat);
                bm2.Save(savePath + f.Name + modifyName(entry.Name, "_c2_"), imageFormat);
            }

            else {
                CropPoint cp = new CropPoint(m_pixels, 0, 0, width, height, depth, searchValue, width, height);
                cp.addMargin(marginUD, marginLR);

                Bitmap bmCrop = m_bm.Clone(cp.getRectangle(), m_bm.PixelFormat);
                bmCrop.Save(savePath + f.Name + modifyName(entry.Name, "_c2_"), imageFormat);
            }


            //Console.WriteLine("[FOUND] x:{0} / y:{1}", x, y);
            //Bitmap bmSnippet = bm.Clone(new Rectangle(x, y, 100, 100), bm.PixelFormat);
            //bmSnippet.Save(getSavePath(f) + f.Name + "_" + entry.Name, System.Drawing.Imaging.ImageFormat.Gif);

            // 가로가 더 긴 경우에는 이미지를 분할하여 저장한다. 
            // 필요없는 부분은 CROP 하여 저장한다.
            // 임시폴더에 저장하고, 
            // 이하 부분은 foreach가 끝나고 나서 처리해야 함.
            // ==> 압축하여, 저장한다.
            // ==> 그리고 임시폴더 삭제
        }

        private string modifyName(string name, string ins)
        {
            string filename = Path.GetFileNameWithoutExtension(name);
            string extentsion = Path.GetExtension(name);
            return filename + ins + extentsion;
        }
        
        public byte[] imageToByteArray(System.Drawing.Image imageIn)
        {
            MemoryStream ms = new MemoryStream();
            imageIn.Save(ms, System.Drawing.Imaging.ImageFormat.Bmp);
            return ms.ToArray();
        }

        private void proccessZipTxt(FileInfo f, ZipArchiveEntry entry)
        {
            String savePath = getSavePath(f);
            String utf8Text = readEntryAsUtf8(entry.Open());
            utf8Text = removeNewLine(utf8Text);
            System.IO.File.WriteAllText(savePath + f.Name + "_" + entry.Name, utf8Text, Encoding.UTF8);
            addMsg(f.Name + " 파일 변환");
        }

        private string getSavePath(FileInfo f)
        {
            return f.DirectoryName + "\\" + MY_FOLDER + "\\";
        }

        private bool isImageFile(ZipArchiveEntry entry)
        {
            string[] exts = { "jpg", "jpeg", "bmp", "gif" };

            foreach (string ext in exts) {
                if (isExtFile(entry.FullName, ext))
                    return true;
            }

            return false;
        }

        private bool isExtFile(string name, string ext)
        {
            if (name.EndsWith("." + ext, StringComparison.OrdinalIgnoreCase)) {
                return true;
            }

            return false;
        }



        private void createDirectory(string path)
        {
            DirectoryInfo di = new DirectoryInfo(path);
            if (di.Exists == false)
                di.Create();
        }

        private void deleteDirectory(string path)
        {
            DirectoryInfo di = new DirectoryInfo(path);
            di.Delete(true);
        }


        private string removeNewLine(string utf8Text)
        {
            string rst = string.Empty;
            string[] stringSeperators = new string[] { "\r\n" };
            string[] lines = utf8Text.Split(stringSeperators, StringSplitOptions.None);

            int insertNewLine = Convert.ToInt32(tbAddEmptyLine.Text);
            int addedLine = 0;

            for (int i = 0; i < lines.Length - 1; i++) {
                string sCur = lines[i];
                string sNext = lines[i + 1];

                string spacePattern = @"(?<=\w)\s+";
                Regex reg = new Regex(spacePattern);
                sCur = reg.Replace(sCur, " ");
                
                bool bAddNewLine = false;

                string pat = @"^\w";
                Regex r = new Regex(pat, RegexOptions.IgnoreCase);
                Match m = r.Match(sNext);

                if (m.Success == false || sCur.Length < 30)
                {
                    bAddNewLine = true;
                }
                else {
                    addedLine++;
                }
                
                if (bAddNewLine)
                {
                    sCur += "\r\n";

                    if (addedLine != 0 && addedLine > insertNewLine)
                    {
                        sCur += "\r\n";
                    }
                    addedLine = 0;
                }

                rst += sCur;
            }

            rst += lines[lines.Length - 1];

            return rst;
        }

        private string readEntryAsUtf8(Stream s)
        {
            Encoding encoding = Encoding.Default;
            String original = String.Empty;

            using (StreamReader sr = new StreamReader(s, Encoding.Default))
            {
                original = sr.ReadToEnd();
                encoding = sr.CurrentEncoding;
                sr.Close();
            }

            if (encoding == Encoding.UTF8)
                return original;

            byte[] encBytes = encoding.GetBytes(original);
            byte[] utf8Bytes = Encoding.Convert(encoding, Encoding.UTF8, encBytes);
            return Encoding.UTF8.GetString(utf8Bytes);
        }


        private String readFileAsUtf8(string filename)
        {
            Encoding encoding = Encoding.Default;
            String original = String.Empty;

            using (StreamReader sr = new StreamReader(filename, Encoding.Default)) {
                original = sr.ReadToEnd();
                encoding = sr.CurrentEncoding;
                sr.Close();                    
            }

            if (encoding == Encoding.UTF8)
                return original;

            byte[] encBytes = encoding.GetBytes(original);
            byte[] utf8Bytes = Encoding.Convert(encoding, Encoding.UTF8, encBytes);
            return Encoding.UTF8.GetString(utf8Bytes);
        }

        private Encoding findFileEncoding(FileInfo f)
        {
            FileStream fs = null;
            int bomByteLen = 4;

            try
            {
                fs = File.OpenRead(f.FullName);
                byte[] BOMBytes = new byte[bomByteLen];
                fs.Read(BOMBytes, 0, bomByteLen);

                if (BOMBytes == null)
                    throw new ArgumentNullException("Must provide a valid BOM byte array!", "BOMBytes");

                if (BOMBytes.Length < 2)
                    return null;

                if (BOMBytes[0] == 0xff
                    && BOMBytes[1] == 0xfe
                    && (BOMBytes.Length < 4
                        || BOMBytes[2] != 0
                        || BOMBytes[3] != 0
                        )
                    )
                    return Encoding.Unicode;

                if (BOMBytes[0] == 0xfe
                    && BOMBytes[1] == 0xff
                    )
                    return Encoding.BigEndianUnicode;

                if (BOMBytes.Length < 3)
                    return null;

                if (BOMBytes[0] == 0xef && BOMBytes[1] == 0xbb && BOMBytes[2] == 0xbf)
                    return Encoding.UTF8;

                if (BOMBytes[0] == 0x2b && BOMBytes[1] == 0x2f && BOMBytes[2] == 0x76)
                    return Encoding.UTF7;

                if (BOMBytes.Length < 4)
                    return null;

                if (BOMBytes[0] == 0xff && BOMBytes[1] == 0xfe && BOMBytes[2] == 0 && BOMBytes[3] == 0)
                    return Encoding.UTF32;

                if (BOMBytes[0] == 0 && BOMBytes[1] == 0 && BOMBytes[2] == 0xfe && BOMBytes[3] == 0xff)
                    return Encoding.GetEncoding(12001);

                return null;

            }
            finally {
                if (fs != null) {
                    fs.Close();
                    fs.Dispose();
                }
            }
        }

        private void addFilesToList(DirectoryInfo di)
        {
            // 마지막 경로가 이 프로그램을 통해서 만든 경로라면 처리하지 않는다.
            int totalLen = di.FullName.Length;
            int myLen = MY_FOLDER.Length;

            if (totalLen > myLen)
            {
                String lastDirectory = di.FullName.Substring(totalLen - myLen, myLen);
                if (lastDirectory == MY_FOLDER)
                    return;
            }

            // 처리 대상 확장자
            string[] exts = { "txt", "zip" };

            // 파일 정보 가져오기
            foreach (System.IO.FileInfo f in di.GetFiles())
            {
                foreach (string ext in exts) {
                    if (f.Extension.EndsWith(ext, StringComparison.OrdinalIgnoreCase)) {
                        m_pathList.Add(f);
                        addMsg(f.FullName + " 파일 추가");
                    }
                }
            }

            // 폴더 정보 가져오기
            foreach (System.IO.DirectoryInfo d in di.GetDirectories()) {
                addFilesToList(d);
            }
        }

        private void tbPath_Drop(object sender, System.Windows.DragEventArgs e)
        {
            if (e.Data.GetDataPresent(System.Windows.DataFormats.FileDrop, true))
            {
                string[] droppedPaths = e.Data.GetData(System.Windows.DataFormats.FileDrop, true) as string[];
                string path = droppedPaths[0];

                DirectoryInfo di = new DirectoryInfo(path);
                string rstPath = string.Empty;

                if (di.Exists)
                {                    
                    rstPath = path;
                }
                else {
                    FileInfo fi = new FileInfo(path);
                    rstPath = fi.DirectoryName;
                }

                changePath(rstPath);
            }
        }

        private void tbPath_PreviewDragEnter(object sender, System.Windows.DragEventArgs e)
        {
            if (e.Data.GetDataPresent(System.Windows.DataFormats.FileDrop))
            {
                e.Effects = System.Windows.DragDropEffects.Copy;
            }
            else
            {
                e.Effects = System.Windows.DragDropEffects.None;
            }
        }

        private void tbPath_PreviewDragOver(object sender, System.Windows.DragEventArgs e)
        {
            e.Handled = true;
        }

        private void NumericOnly(System.Object sender, System.Windows.Input.TextCompositionEventArgs e) {
            e.Handled = IsTextNumeric(e.Text);
        }

        private bool IsTextNumeric(string str) {
            System.Text.RegularExpressions.Regex reg = new System.Text.RegularExpressions.Regex("[^0-9]");
            return reg.IsMatch(str);
        }



    }
}
